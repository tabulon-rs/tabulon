// Re-exported metadata for functions collected via #[function]
#[derive(Clone, Copy)]
pub struct FnMeta {
    pub name: &'static str,
    pub arity: u8,
    pub addr: *const u8,
    pub mod_path: &'static str,
    pub uses_ctx: bool,
    pub ctx_type_name_fn: Option<fn() -> &'static str>,
}

// Safe because addr points to a 'static extern "C" function shim generated by the macro
unsafe impl Sync for FnMeta {}

inventory::collect!(FnMeta);

/// A trait to extract the context type from an engine instance.
pub trait HasCtx {
    type Ctx;
}

impl<Ctx> HasCtx for crate::engine::Tabula<Ctx> {
    type Ctx = Ctx;
}

#[macro_export]
macro_rules! register_functions {
    ($eng:expr, $($name:ident),+ $(,)?) => {{
        // Determine the engine's context type name at compile site (works with non-'static lifetimes)
        #[allow(dead_code)]
        fn __tabulon_engine_ctx_type_name<E: $crate::HasCtx>(_: &E) -> &'static str {
            ::core::any::type_name::<<E as $crate::HasCtx>::Ctx>()
        }
        let __eng_tname = __tabulon_engine_ctx_type_name(&$eng);

        // Normalize lifetime annotations in type names to compare family-equality ignoring lifetimes.
        fn __tabulon_normalize_type_name(mut s: &str) -> std::borrow::Cow<'_, str> {
            use std::borrow::Cow;
            // Fast-path: if no single-quote, return as-is
            if !s.as_bytes().contains(&b'\'') { return Cow::Borrowed(s); }
            let mut out = String::with_capacity(s.len());
            let bytes = s.as_bytes();
            let mut i = 0;
            while i < bytes.len() {
                let c = bytes[i] as char;
                if c == '\'' {
                    // write the single quote
                    out.push('\'');
                    // skip lifetime name characters [A-Za-z0-9_]
                    i += 1;
                    while i < bytes.len() {
                        let c2 = bytes[i] as char;
                        if c2.is_alphanumeric() || c2 == '_' { i += 1; } else { break; }
                    }
                    // normalize to underscore
                    out.push('_');
                    continue;
                }
                out.push(c);
                i += 1;
            }
            Cow::Owned(out)
        }

        let mut res: Result<(), $crate::JitError> = Ok(());
        let wanted: &[&str] = &[ $( stringify!($name) ),+ ];
        for meta in $crate::inventory::iter::<$crate::FnMeta> {
            if wanted.contains(&meta.name) {
                // Runtime type-check to prevent mismatched context registration
                if meta.uses_ctx {
                    if let Some(ctx_tname_fn) = meta.ctx_type_name_fn {
                        let f_tname_norm = __tabulon_normalize_type_name((ctx_tname_fn)());
                        let eng_tname_norm = __tabulon_normalize_type_name(__eng_tname);
                        if f_tname_norm != eng_tname_norm {
                            res = Err($crate::JitError::Internal(format!(
                                "context type mismatch when registering {}: engine Ctx does not match function's Ctx (engine={}, func={})",
                                meta.name, __eng_tname, (ctx_tname_fn)()
                            )));
                            break;
                        }
                    }
                }
                res = res.and_then(|_| unsafe {
                    match meta.arity {
                        0 => $eng.register_nullary(meta.name, std::mem::transmute::<*const u8, $crate::Fn0>(meta.addr), meta.uses_ctx),
                        1 => $eng.register_unary(meta.name, std::mem::transmute::<*const u8, $crate::Fn1>(meta.addr), meta.uses_ctx),
                        2 => $eng.register_binary(meta.name, std::mem::transmute::<*const u8, $crate::Fn2>(meta.addr), meta.uses_ctx),
                        3 => $eng.register_ternary(meta.name, std::mem::transmute::<*const u8, $crate::Fn3>(meta.addr), meta.uses_ctx),
                        _ => Err($crate::JitError::Internal(format!("unsupported arity {} for {}", meta.arity, meta.name))),
                    }
                });
            }
        }
        res
    }};
}

#[macro_export]
macro_rules! register_functions_typed {
    ($eng:expr, $($marker:path),+ $(,)?) => {{
        let mut res: Result<(), $crate::JitError> = Ok(());
        $(
            res = res.and_then(|_| $eng.register_typed::<$marker>());
        )+
        res
    }};
}

/// Type-equality helper for compile-time context matching (EngineCtx == FunctionCtx).
pub trait SameAs<T> {}
impl<T> SameAs<T> for T {}

/// Function metadata bound to an engine context type. Implemented by #[function]-generated markers.
pub trait FunctionForEngineCtx<EngineCtx> {
    const NAME: &'static str;
    const ARITY: u8;
    const USES_CTX: bool;
    fn addr() -> *const u8;
}

/// Resolver metadata bound to an engine context type. Implemented by #[resolver]-generated markers.
pub trait ResolverForEngineCtx<EngineCtx> {
    /// Symbol name to register with the JIT for this resolver.
    const NAME: &'static str;
    /// Address of the generated extern "C" shim: fn(ctx: *mut c_void, idx: u32) -> f64
    fn addr() -> *const u8;
}

#[macro_export]
macro_rules! register_resolver_typed {
    ($eng:expr, $marker:path) => {{
        $eng.set_var_getter_typed::<$marker>()
    }};
}
